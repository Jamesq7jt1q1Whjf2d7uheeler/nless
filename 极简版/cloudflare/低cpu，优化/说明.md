# Cloudflare Worker 脚本 CPU Time 性能深度分析

## 结论
版本1也就是这个一版。版本2就是极简版
版本 1 的 CPU Time 会显著低于版本 2。

版本 1 是一份经过深度优化的代码，几乎在每一个计算细节上都采用了比版本 2 更高效、更底层的实现方法。版本 2 虽然功能完整且易于理解，但其实现方式包含了更多高层次的抽象，这些抽象在运行时会转化成额外的 CPU 开销。

## 详细对比分析

| 对比项             | 版本 1 (高性能版)                                               | 版本 2 (标准版)                                                     | CPU Time 优胜者    |
| ------------------ | ---------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------ |
| 核心安全检查       | 完全移除。直接跳过所有 UUID 解析和验证的计算，这是最大的性能提升点。 | 完整 UUID 验证。包含 slice 内存拷贝、map 循环、多次 toString(16) 转换和 includes 数组查找，CPU 开销巨大。 | 版本 1 (巨大优势) |
| URL 解析           | 使用 indexOf 和 substring。这是非常快速的底层字符串操作。        | 使用 new URL(rq.url)。这会创建一个完整的 URL 对象，开销远大于简单的字符串查找。 | 版本 1             |
| 端口号解析         | 使用位运算 (ms[of] << 8) \| ms[of + 1]。直接对字节进行操作，这是 JavaScript 中最快的整数解析方式。 | 使用 new DataView(...) 和 dv.getUint16()。这需要创建 DataView 对象和一次函数调用，比位运算慢。 | 版本 1             |
| IPv6 地址解析      | 在 for 循环中同样使用位运算来组合16位整数。极其高效。            | 使用 dv.getUint16()，并且依赖了高阶函数 Array.from 和 .join()，函数调用和中间数组的开销更大。 | 版本 1             |
| 文本解码           | 在全局创建了一个 TextDecoder 实例 (td)，所有请求共享使用，避免了重复创建对象的开销。 | 在 switch 语句中隐式地 new TextDecoder().decode(...)，每次需要时都可能创建一个新实例。 | 版本 1             |
| 错误抛出           | 使用 throw 0。这是一个微优化，抛出一个原始值比创建完整的 Error 对象要快，因为它不需要构造堆栈跟踪信息。 | 使用 throw new Error()。这是标准做法，但开销略高。                       | 版本 1             |
| 代码哲学           | 性能至上。旨在减少每一次函数调用、对象创建和内存分配，尽可能使用底层操作。 | 可读性优先。遵循了更标准的 JavaScript 实践，但这些实践本身就带有一定的性能开销。 | 版本 1             |